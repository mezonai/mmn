name: Deploy MMN
permissions:
  contents: write

on:
  workflow_dispatch:
    inputs:
      env:
        description: "Environment (dev|prod)"
        required: true
        default: "dev"
      ref:
        description: "Git ref (branch, tag, or commit)"
        required: true
        default: "master"
      new_tag_to_build:
        description: "(Optional) New tag"
        required: false
      existing_tag_to_deploy:
        description: "(Optional) Existing tag"
        required: false

jobs:
  determine_tag:
    runs-on: ubuntu-latest
    if: github.event.inputs.new_tag_to_build == '' && github.event.inputs.existing_tag_to_deploy == ''
    outputs:
      new_tag: ${{ steps.get_tag.outputs.new_tag }}
      is_run: "true"
    steps:
      - name: Checkout for git history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Calculate new tag
        id: get_tag
        run: |
          echo "==> No new or existing tag provided. Calculating the next tag..."

          LATEST_TAG=$(git tag -l --sort=-v:refname | head -n 1)
          if [ -z "$LATEST_TAG" ]; then
            NEW_TAG="v0.1.0"
            echo "==> No existing tags found. Starting with initial tag: $NEW_TAG"
          else
            echo "==> Latest tag is: $LATEST_TAG"
            VERSION=$(echo $LATEST_TAG | sed 's/^v//')
            MAJOR=$(echo $VERSION | cut -d. -f1)
            MINOR=$(echo $VERSION | cut -d. -f2)
            PATCH=$(echo $VERSION | cut -d. -f3)
            NEXT_PATCH=$((PATCH + 1))
            NEW_TAG="v${MAJOR}.${MINOR}.${NEXT_PATCH}"
            echo "==> Calculated next tag: $NEW_TAG"
          fi
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT

  build:
    needs: determine_tag
    if: |
      always() && (
        github.event.inputs.existing_tag_to_deploy != '' ||
        github.event.inputs.new_tag_to_build != '' ||
        needs.determine_tag.outputs.is_run == 'true'
      )
    runs-on: [self-hosted, Linux, mezon-runner]
    outputs:
      tag_name: ${{ steps.determine_release_tag.outputs.tag }}
    steps:
      - name: Decide whether to build
        id: decide
        run: |
          if [ -n "${{ inputs.existing_tag_to_deploy }}" ]; then
            echo "==> Skipping build because 'existing_tag_to_deploy' is set. Will deploy directly."
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "==> Proceeding with new build."
            echo "skip=false" >> $GITHUB_OUTPUT
          fi
      - name: Checkout
        if: steps.decide.outputs.skip == 'false'
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}
      
      - name: Get Git Commit SHA
        if: steps.decide.outputs.skip == 'false'
        id: get_sha
        run: echo "sha=$(git rev-parse --short=12 HEAD)" >> $GITHUB_OUTPUT

      - name: Setup Go
        if: steps.decide.outputs.skip == 'false'
        uses: actions/setup-go@v5
        with:
          go-version: "1.22.5"
          cache: true
          check-latest: false

      - name: Install build dependencies
        if: steps.decide.outputs.skip == 'false'
        run: |
          PACKAGES="
          build-essential
          libsnappy-dev
          zlib1g-dev
          libbz2-dev
          libgflags-dev
          liblz4-dev
          libzstd-dev
          liburing-dev
          "
          TO_INSTALL=""
          echo "==> Checking for required packages..."
          for PKG in $PACKAGES; do
            if ! dpkg -s "$PKG" &> /dev/null; then
              TO_INSTALL="$TO_INSTALL $PKG"
            fi
          done

          if [ -n "$TO_INSTALL" ]; then
            echo "==> Found missing packages, installing: $TO_INSTALL"
            sudo apt-get update
            sudo apt-get install -y $TO_INSTALL
          else
            echo "==> All build dependencies are already installed. Skipping."
          fi

      - name: Determine and Standardize Tag for Release
        if: steps.decide.outputs.skip == 'false'
        id: determine_release_tag
        run: |
          if [ -n "${{ inputs.new_tag_to_build }}" ]; then
            TAG_INPUT="${{ inputs.new_tag_to_build }}"
          else
            TAG_INPUT="${{ needs.determine_tag.outputs.new_tag }}"
          fi

          if [[ ! "$TAG_INPUT" == v* ]]; then
            TAG_TO_USE="v$TAG_INPUT"
            echo "==> Prefix 'v' was missing. Standardizing to: $TAG_TO_USE"
          else
            TAG_TO_USE="$TAG_INPUT"
          fi

          echo "==> Using tag for release: $TAG_TO_USE"
          echo "tag=$TAG_TO_USE" >> $GITHUB_OUTPUT

      - name: Build MMN binary
        if: steps.decide.outputs.skip == 'false'
        id: build
        env:
          CGO_ENABLED: 1
          CGO_CFLAGS: "-I$(pwd)/libs/rocksdb"
          CGO_LDFLAGS: "-L$(pwd)/libs -lrocksdb -lstdc++ -lm -lz -lbz2 -lsnappy -llz4 -lzstd -luring"
        run: |
          mkdir -p build
          GOOS=linux GOARCH=amd64 go build -tags rocksdb -o "build/mmn-${{ steps.determine_release_tag.outputs.tag }}" .
          GIT_SHA=$(git rev-parse --short=12 HEAD)

      - name: Create Release and Upload Binary
        if: steps.decide.outputs.skip == 'false'
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.determine_release_tag.outputs.tag }}
          name: "Release ${{ steps.determine_release_tag.outputs.tag }}"
          fail_on_unmatched_files: true
          files: |
            build/mmn-${{ steps.determine_release_tag.outputs.tag }}
      
      - name: Upload binary for deployment job
        if: steps.decide.outputs.skip == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: mmn-binary-${{ steps.determine_release_tag.outputs.tag }}
          path: build/mmn-${{ steps.determine_release_tag.outputs.tag }}

  deploy:
    needs: [determine_tag, build]
    if: always()
    runs-on: [self-hosted, Linux, mezon-runner]
    environment: ${{ inputs.env }}
    env:
      TARGET_HOST: ${{ inputs.env == 'prod' && 'prod-mmn' || 'dev-mmn' }}
    steps:
      - name: Determine Binary Path and Tag
        id: determine_binary
        run: |
          TAG_INPUT=""
          if [ -n "${{ inputs.existing_tag_to_deploy }}" ]; then
            TAG_INPUT="${{ inputs.existing_tag_to_deploy }}"
            echo "==> Will deploy existing tag: $TAG_INPUT"
          elif [ "${{ needs.build.result }}" == "success" ]; then
            TAG_INPUT="${{ needs.build.outputs.tag_name }}"
            echo "==> Will deploy newly built tag: $TAG_INPUT"
          else
            echo "::error::Cannot proceed. No existing tag was provided and the build job did not succeed."
            exit 1
          fi

          if [[ ! "$TAG_INPUT" == v* ]]; then
            TAG_TO_DEPLOY="v$TAG_INPUT"
            echo "==> Prefix 'v' was missing. Standardizing to: $TAG_TO_DEPLOY"
          else
            TAG_TO_DEPLOY="$TAG_INPUT"
          fi
          
          echo "tag_name=$TAG_TO_DEPLOY" >> $GITHUB_OUTPUT
          echo "binary_name=mmn-$TAG_TO_DEPLOY" >> $GITHUB_OUTPUT
          echo "binary_path=build/mmn-$TAG_TO_DEPLOY" >> $GITHUB_OUTPUT
      
      - name: Checkout code for config files
        uses: actions/checkout@v4

      - name: Install GitHub CLI (if not present)
        run: |
          if command -v gh &> /dev/null; then
            echo "==> GitHub CLI is already installed. Skipping."
            gh --version
          else
            set -e
            echo "==> GitHub CLI not found. Starting robust installation..."

            echo "==>Cleaning up any old GitHub CLI configurations to ensure a fresh install."
            sudo rm -f /etc/apt/sources.list.d/github-cli.list
            sudo rm -f /usr/share/keyrings/githubcli-archive-key.gpg
            sudo rm -f /etc/apt/keyrings/githubcli-archive-key.gpg

            echo "==> Adding the official GPG key and repository."
            (type -p wget >/dev/null || (sudo apt-get update && sudo apt-get install wget -y)) && \
            sudo mkdir -p -m 755 /etc/apt/keyrings && \
            wget -qO- https://cli.github.com/packages/githubcli-archive-key.gpg | sudo tee /etc/apt/keyrings/githubcli-archive-key.gpg > /dev/null && \
            sudo chmod go+r /etc/apt/keyrings/githubcli-archive-key.gpg && \
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-key.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null && \
            sudo apt-get update && \
            sudo apt-get install gh -y
            echo "==> GitHub CLI installed successfully."
            gh --version
          fi

      - name: Prepare binary for deployment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p build
          if [ -n "${{ inputs.existing_tag_to_deploy }}" ]; then
            echo "==> Downloading binary from release..."
            gh release download "${{ steps.determine_binary.outputs.tag_name }}" --pattern "${{ steps.determine_binary.outputs.binary_name }}" --output "${{ steps.determine_binary.outputs.binary_path }}"
          else
            echo "==> Getting binary from the build job's artifact."
          fi

      - name: Get binary from build job (if new build)
        if: inputs.existing_tag_to_deploy == ''
        uses: actions/download-artifact@v4
        with:
          name: mmn-binary-${{ steps.determine_binary.outputs.tag_name }}
          path: build/

      - name: Check if binary exists
        run: |
          if [ ! -f "${{ steps.determine_binary.outputs.binary_path }}" ]; then
            echo "Error: Binary '${{ steps.determine_binary.outputs.binary_path }}' not found."
            exit 1
          fi
          echo "==> Binary is ready for deployment."

      - name: Deploy Monitoring Configurations
        env:
          URL_LOKI_PUSH: ${{ vars.URL_LOKI_PUSH }}
        run: |
          set -e
          echo "==> Deploying monitoring configs for MMN..."
          ssh -i /home/nccsoft/.ssh/mmn_deploy ${{ secrets.HOST_ALIAS }} "
            set -e
            sudo mkdir -p /etc/mezon/monitoring
            sudo chown mmn:mmn /etc/mezon/monitoring
          "

          echo "==> Copying configs to a temporary location on the MMN server..."
          scp -i /home/nccsoft/.ssh/mmn_deploy ./monitoring/promtail-config.yml ${{ secrets.HOST_ALIAS }}:/tmp/promtail-config.yml

          echo "==> Moving configs to final destination with sudo..."
          ssh -i /home/nccsoft/.ssh/mmn_deploy ${{ secrets.HOST_ALIAS }} <<EOF
            set -e
            sed \
              -e "s|__URL_LOKI_PUSH__|${URL_LOKI_PUSH}|g" \
              -e 's|__path__: /var/log/mmn/\*.log|__path__: /opt/mezon/mmn/logs/\*.log|g' \
              /tmp/promtail-config.yml \
              | sudo tee /etc/mezon/monitoring/promtail-config.yml >/dev/null
            sudo chown mmn:mmn /etc/mezon/monitoring/promtail-config.yml
          EOF
      
      - name: Monitoring config server runner
        if: inputs.env == 'prod'
        env:
          PORT_NODE_EXPORTER: ${{ vars.PORT_NODE_EXPORTER }}
          NODE1_URL_PORT: ${{ vars.NODE1_URL_PORT }}
          LISTENER_URL_PORT: ${{ vars.LISTENER_URL_PORT }}
        run: |
          echo "==> Move config file to folder run monitoring..."
          sudo mkdir -p /etc/mezon/monitoring/
          echo "==> Setting up Prometheus and Loki configs..."
          sudo cp ./monitoring/prometheus-config.yml /etc/mezon/monitoring/prometheus-config.yml
          sudo cp ./monitoring/loki-config.yml /etc/mezon/monitoring/loki-config.yml

          sudo sed -i "s/__PORT_NODE_EXPORTER__/${PORT_NODE_EXPORTER}/g" /etc/mezon/monitoring/prometheus-config.yml
          sudo chown mmn:mmn /etc/mezon/monitoring/prometheus-config.yml
          sudo chown mmn:mmn /etc/mezon/monitoring/loki-config.yml

          echo "==> Setting up Grafana configs..."
          sudo mkdir -p /etc/grafana/
          sudo cp -r ./monitoring/grafana/* /etc/grafana/
          
          sudo chown -R mmn:mmn /etc/grafana/provisioning
          sudo chown -R mmn:mmn /etc/grafana/dashboards
          sudo sed -i 's#url: http://loki:3100#url: http://localhost:3100#g' /etc/grafana/provisioning/datasources/loki.yml
          sudo sed -i 's#url: http://prometheus:9090#url: http://localhost:9090#g' /etc/grafana/provisioning/datasources/prometheus.yml
          sudo sed -i 's#path: /var/lib/grafana/dashboards#path: /etc/grafana/dashboards#g' /etc/grafana/provisioning/dashboards/dashboard.yaml

          sudo mkdir -p /etc/prometheus/targets
          sudo cp ./monitoring/prometheus/targets/nodes.example.yml /etc/prometheus/targets/nodes.yml
          sudo sed -i -e "s#__NODE1_URL_PORT__#${NODE1_URL_PORT}#g" -e "s#__LISTENER_URL_PORT__#${LISTENER_URL_PORT}#g" /etc/prometheus/targets/nodes.yml
          sudo chown mmn:mmn /etc/prometheus/targets/nodes.yml

      - name: Deploy Full Monitoring Stack to Dev Server
        if: inputs.env == 'dev'
        env:
          PORT_NODE_EXPORTER: ${{ vars.PORT_NODE_EXPORTER }}
          NODE1_URL_PORT: ${{ vars.NODE1_URL_PORT }}
          LISTENER_URL_PORT: ${{ vars.LISTENER_URL_PORT }}
        run: |
          set -e
          echo "==> 1. Preparing monitoring configs on the runner..."

          cp -r ./monitoring ./monitoring_deploy_temp

          sed -i "s/__PORT_NODE_EXPORTER__/${PORT_NODE_EXPORTER}/g" ./monitoring_deploy_temp/prometheus-config.yml
          sed -i -e "s#__NODE1_URL_PORT__#${NODE1_URL_PORT}#g" -e "s#__LISTENER_URL_PORT__#${LISTENER_URL_PORT}#g" ./monitoring_deploy_temp/prometheus/targets/nodes.example.yml

          echo "==> 2. Copying prepared monitoring stack to the dev server..."
          ssh -i /home/nccsoft/.ssh/mmn_deploy ${{ secrets.HOST_ALIAS }} "
            set -e
            sudo mkdir -p /etc/mezon/monitoring
            sudo chown mmn:mmn /etc/mezon/monitoring
          "
          ssh -i /home/nccsoft/.ssh/mmn_deploy ${{ secrets.HOST_ALIAS }} "
            set -e
            sudo mkdir -p /tmp/monitoring_deploy
            sudo chown mmn:mmn /tmp/monitoring_deploy
          "
          scp -i /home/nccsoft/.ssh/mmn_deploy -r ./monitoring_deploy_temp/* ${{ secrets.HOST_ALIAS }}:/tmp/monitoring_deploy

          echo "==> 3. Running setup script on the dev server..."
          ssh -i /home/nccsoft/.ssh/mmn_deploy ${{ secrets.HOST_ALIAS }} <<'EOF'
            set -e
            echo "--> Preparing directories on remote server..."
            sudo mkdir -p /etc/mezon/monitoring/ /etc/grafana/ /etc/prometheus/targets

            echo "--> Setting up Prometheus..."
            sudo mv /tmp/monitoring_deploy/prometheus-config.yml /etc/mezon/monitoring/prometheus-config.yml
            sudo mv /tmp/monitoring_deploy/prometheus/targets/nodes.example.yml /etc/prometheus/targets/nodes.yml
            sudo chown mmn:mmn /etc/mezon/monitoring/prometheus-config.yml
            sudo chown mmn:mmn /etc/prometheus/targets/nodes.yml

            echo "--> Setting up Loki..."
            sudo mv /tmp/monitoring_deploy/loki-config.yml /etc/mezon/monitoring/loki-config.yml
            sudo chown mmn:mmn /etc/mezon/monitoring/loki-config.yml

            echo "--> Setting up Grafana..."
            sudo cp -r /tmp/monitoring_deploy/grafana/* /etc/grafana/
            
            sudo chown -R grafana:grafana /etc/grafana/provisioning
            sudo chown -R grafana:grafana /etc/grafana/dashboards

            sudo sed -i 's#url: http://loki:3100#url: http://localhost:3100#g' /etc/grafana/provisioning/datasources/loki.yml
            sudo sed -i 's#url: http://prometheus:9090#url: http://localhost:9090#g' /etc/grafana/provisioning/datasources/prometheus.yml
            sudo sed -i 's#path: /var/lib/grafana/dashboards#path: /etc/grafana/dashboards#g' /etc/grafana/provisioning/dashboards/dashboard.yaml
            echo "--> Cleaning up temporary files..."
            sudo rm -rf /tmp/monitoring_deploy

            echo "Full monitoring stack deployed to dev server."
          EOF

      - name: Copy binary and config to target
        run: |
          scp -i /home/nccsoft/.ssh/mmn_deploy ${{ steps.determine_binary.outputs.binary_path }} ${{ secrets.HOST_ALIAS }}:/opt/mezon/mmn/staging/mmn_new
          scp -i /home/nccsoft/.ssh/mmn_deploy config/genesis.template.yml ${{ secrets.HOST_ALIAS }}:/opt/mezon/mmn/config/

      - name: Generate remote setup and env files locally
        run: |
          cat > remote_setup.sh <<'EOF'
          #!/usr/bin/env bash
          set -euo pipefail

          echo "==> Loading environment..."
          source /tmp/mezon_env.sh

          echo "==> Checking and installing runtime dependencies..."
          RUNTIME_PACKAGES="
          libsnappy1v5
          zlib1g
          libbz2-1.0
          liblz4-1
          libzstd1
          liburing2
          "
          TO_INSTALL_REMOTE=""
          for PKG in $RUNTIME_PACKAGES; do
            if ! dpkg -s "$PKG" &> /dev/null; then
              TO_INSTALL_REMOTE="$TO_INSTALL_REMOTE $PKG"
            fi
          done

          if [ -n "$TO_INSTALL_REMOTE" ]; then
            echo "==> Found missing runtime packages on target server, installing: $TO_INSTALL_REMOTE"
            sudo apt-get update -y
            sudo apt-get install -y $TO_INSTALL_REMOTE
          else
            echo "==> All runtime dependencies are already installed on target server. Skipping."
          fi

          echo "==> Preparing directories..."
          sudo mkdir -p /etc/mezon /opt/mezon/mmn/bin /opt/mezon/node-data

          write_text_file() {
            local var_value="$1"
            local dest="$2"
            if [ -z "$var_value" ]; then
              echo "❌ ERROR: Missing value for $dest"
              exit 1
            fi
            printf '%s' "$var_value" | sudo tee "$dest" >/dev/null
            sudo chmod 600 "$dest"
            sudo chown mmn:mmn "$dest"
          }

          echo "==> Writing keys..."
          write_text_file "$BOOTNODE_PRIVKEY" /etc/mezon/bootnode_privkey.txt
          write_text_file "$NODE1_PRIVKEY" /etc/mezon/node1_privkey.txt
          write_text_file "$VERIFYING_KEY_B64" /opt/mezon/mmn/config/verifying_key.b64

          echo "==> Generating genesis.yml..."
          sed \
            -e "s|__LEADER_ADDRESS__|$NODE1_ADDRESS|g" \
            -e "s|__FAUCET_ADDRESS__|$FAUCET_ADDRESS|g" \
            /opt/mezon/mmn/config/genesis.template.yml \
            | sudo tee /etc/mezon/genesis.yml >/dev/null
          sudo chown mmn:mmn /etc/mezon/genesis.yml

          echo "==> Updating systemd for node1..."
          BOOTNODE_MULTIADDR="/ip4/$BOOTNODE_IP/tcp/9000/p2p/$BOOTNODE_ID"
          sed -e "s|__BOOTNODE_MULTIADDR__|$BOOTNODE_MULTIADDR|g" \
              /opt/mezon/mmn/config/systemd/mezon-node1.service.tpl \
              | sudo tee /etc/systemd/system/mezon-node1.service >/dev/null

          echo "==> Creating /etc/mezon/node1.env..."
          sudo tee /etc/mezon/node1.env >/dev/null <<EOL
          LOGFILE=node1.log
          LOGLEVEL=info
          LOGFILE_MAX_SIZE_MB=500
          LOGFILE_MAX_AGE_DAYS=30
          CORS_ALLOWED_ORIGINS=*
          CORS_ALLOWED_METHODS=POST,OPTIONS
          CORS_ALLOWED_HEADERS=Content-Type
          EOL

          sudo chmod 644 /etc/mezon/node1.env
          sudo chown mmn:mmn /etc/mezon/node1.env

          sudo systemctl daemon-reload
          sudo systemctl enable mezon-node1

          echo "✅ Remote setup completed successfully."
          EOF

          chmod +x remote_setup.sh

          echo "# Mezon env generated at $(date)" > mezon_env.sh
          printf "export BOOTNODE_PRIVKEY=%q\n" "$BOOTNODE_PRIVKEY" >> mezon_env.sh
          printf "export NODE1_PRIVKEY=%q\n" "$NODE1_PRIVKEY" >> mezon_env.sh
          printf "export VERIFYING_KEY_B64=%q\n" "$VERIFYING_KEY_B64" >> mezon_env.sh
          printf "export NODE1_ADDRESS=%q\n" "$NODE1_ADDRESS" >> mezon_env.sh
          printf "export FAUCET_ADDRESS=%q\n" "$FAUCET_ADDRESS" >> mezon_env.sh
          printf "export BOOTNODE_IP=%q\n" "$BOOTNODE_IP" >> mezon_env.sh
          printf "export BOOTNODE_ID=%q\n" "$BOOTNODE_ID" >> mezon_env.sh
        env:
          BOOTNODE_PRIVKEY:  ${{ secrets.BOOTNODE_PRIVKEY }}
          NODE1_PRIVKEY:     ${{ secrets.NODE1_PRIVKEY }}
          VERIFYING_KEY_B64: ${{ secrets.VERIFYING_KEY_B64 }}
          NODE1_ADDRESS:     ${{ secrets.NODE1_ADDRESS }}
          FAUCET_ADDRESS:    ${{ secrets.FAUCET_ADDRESS }}
          BOOTNODE_IP:       ${{ secrets.BOOTNODE_IP }}
          BOOTNODE_ID:       ${{ secrets.BOOTNODE_ID }}

      - name: Execute remote setup correctly with sourced env
        shell: bash
        env:
          BOOTNODE_PRIVKEY:  ${{ secrets.BOOTNODE_PRIVKEY }}
          NODE1_PRIVKEY:     ${{ secrets.NODE1_PRIVKEY }}
          VERIFYING_KEY_B64: ${{ secrets.VERIFYING_KEY_B64 }}
          NODE1_ADDRESS:     ${{ secrets.NODE1_ADDRESS }}
          FAUCET_ADDRESS:    ${{ secrets.FAUCET_ADDRESS }}
          BOOTNODE_IP:       ${{ secrets.BOOTNODE_IP }}
          BOOTNODE_ID:       ${{ secrets.BOOTNODE_ID }}
        run: |
          set -e

          echo "==> Copying remote_setup.sh and mezon_env.sh..."
          scp -i /home/nccsoft/.ssh/mmn_deploy remote_setup.sh mezon_env.sh ${{ secrets.HOST_ALIAS }}:/tmp/

          echo "==> Running remote setup..."
          ssh -i /home/nccsoft/.ssh/mmn_deploy ${{ secrets.HOST_ALIAS }} "
            set -e
            chmod +x /tmp/remote_setup.sh
            bash -c 'set -e; source /tmp/mezon_env.sh; bash /tmp/remote_setup.sh'
            rm -f /tmp/mezon_env.sh /tmp/remote_setup.sh
          "

      - name: Atomic swap + restart services
        run: |
          ssh -i /home/nccsoft/.ssh/mmn_deploy ${{ secrets.HOST_ALIAS }} <<'EOF'
          set -e
          SHA=$(date +%s)

          sudo systemctl stop mezon-node1 || true
          sudo systemctl stop mezon-bootnode || true

          sudo install -m 0755 /opt/mezon/mmn/staging/mmn_new /opt/mezon/mmn/bin/mmn-${SHA}
          sudo ln -sfn mmn-${SHA} /opt/mezon/mmn/bin/mmn

          if [ ! -d "/opt/mezon/node-data/node1" ]; then
            set -a
            source /etc/mezon/node1.env
            set +a
            /opt/mezon/mmn/bin/mmn init \
              --data-dir "/opt/mezon/node-data/node1" \
              --genesis "/etc/mezon/genesis.yml" \
              --database rocksdb \
              --privkey-path "/etc/mezon/node1_privkey.txt"
          fi

          sudo systemctl start mezon-bootnode || true
          sleep 2
          sudo systemctl start mezon-node1 || true
          EOF

      - name: Healthcheck
        run: |
          ssh -i /home/nccsoft/.ssh/mmn_deploy ${{ secrets.HOST_ALIAS }} "sudo systemctl --no-pager -l status mezon-node1 | tail -n 50"
          ssh -i /home/nccsoft/.ssh/mmn_deploy ${{ secrets.HOST_ALIAS }} "curl -sSf http://127.0.0.1:8081/health || true"
